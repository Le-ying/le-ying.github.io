<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kung&#39;s Blog</title>
  
  <subtitle>欢迎来到我的博客!</subtitle>
  <link href="https://serika-onoe.github.io/atom.xml" rel="self"/>
  
  <link href="https://serika-onoe.github.io/"/>
  <updated>2022-12-22T06:03:13.538Z</updated>
  <id>https://serika-onoe.github.io/</id>
  
  <author>
    <name>龚泽颖</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CS231n Assignment 1</title>
    <link href="https://serika-onoe.github.io/2022/12/20/CS231n-Assignment-1/"/>
    <id>https://serika-onoe.github.io/2022/12/20/CS231n-Assignment-1/</id>
    <published>2022-12-20T14:49:13.000Z</published>
    <updated>2022-12-22T06:03:13.538Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cs231n-assignment-1">CS231n Assignment 1</h1><p>作业1分为五个部分：knn、SVM、Softmax classifier、2层神经网络、HigherLevel Representations: Image Features.</p><p>建议作业完成顺序：</p><ol type="1"><li>k近邻分类：knn.ipynb &amp; k_nearest_neighbor.py</li><li>svm线性分类：svm.ipynb &amp; linear_svm.py &amp;linear_classifier.py</li><li>softmax线性分类：softmax.ipynb &amp; softmax.py</li><li>两层神经网络：two_layer_net.ipynb &amp; neural_net.py</li></ol><h1 id="k-nearest-neighbor-knn-exercise">k-Nearest Neighbor (kNN)exercise</h1><p>在knn.ipynb中，调用了k_nearest_neighbor.py文件。</p><p>k近邻分类算法步骤如下介绍：</p><ol type="1"><li>记住所有训练图像</li><li>计算测试图像与所有训练图像的距离（常用L2距离）</li><li>选择与测试图像距离最小的k张训练图像</li><li>计算这k张图像所对应的类别出现的次数，选择出现次数最多的类别记为预测类别</li></ol><h2 id="k_nearest_neighbor.py">k_nearest_neighbor.py</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">KNearestNeighbor</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; a kNN classifier with L2 distance &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment">#定义一个k近邻分类器的类</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h3 id="训练">训练</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">self, X, y</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Train the classifier. For k-nearest neighbors this is just</span></span><br><span class="line"><span class="string">    memorizing the training data.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Inputs:</span></span><br><span class="line"><span class="string">    - X: A numpy array of shape (num_train, D) containing the training data</span></span><br><span class="line"><span class="string">      consisting of num_train samples each of dimension D.</span></span><br><span class="line"><span class="string">    - y: A numpy array of shape (N,) containing the training labels, where</span></span><br><span class="line"><span class="string">         y[i] is the label for X[i].</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment">#self.X_train 是训练数据，维度是 (N,D)，训练集有N个样本，每个样本特征是D维</span></span><br><span class="line">    <span class="comment">#self.y_train 是标签，维度是（N,）,即N个训练样本对应的标签</span></span><br><span class="line">    self.X_train = X</span><br><span class="line">    self.y_train = y</span><br></pre></td></tr></table></figure><h3id="预测计算测试图像和所有训练图像的l2距离">预测：计算测试图像和所有训练图像的L2距离</h3><p>预测时首先需要计算测试样本与所有训练样本的距离,然后根据距离判断样本的类别。</p><p>计算距离需要我们实现三种方法，分别为需要双重循环，单循环，不需要循环。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self, X, k=<span class="number">1</span>, num_loops=<span class="number">0</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Predict labels for test data using this classifier.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Inputs:</span></span><br><span class="line"><span class="string">    - X: A numpy array of shape (num_test, D) containing test data consisting</span></span><br><span class="line"><span class="string">         of num_test samples each of dimension D.</span></span><br><span class="line"><span class="string">    - k: The number of nearest neighbors that vote for the predicted labels.</span></span><br><span class="line"><span class="string">    - num_loops: Determines which implementation to use to compute distances</span></span><br><span class="line"><span class="string">      between training points and testing points.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    - y: A numpy array of shape (num_test,) containing predicted labels for the</span></span><br><span class="line"><span class="string">      test data, where y[i] is the predicted label for the test point X[i].</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> num_loops == <span class="number">0</span>:</span><br><span class="line">        dists = self.compute_distances_no_loops(X)</span><br><span class="line">    <span class="keyword">elif</span> num_loops == <span class="number">1</span>:</span><br><span class="line">        dists = self.compute_distances_one_loop(X)</span><br><span class="line">    <span class="keyword">elif</span> num_loops == <span class="number">2</span>:</span><br><span class="line">        dists = self.compute_distances_two_loops(X)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;Invalid value %d for num_loops&quot;</span> % num_loops)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> self.predict_labels(dists, k=k)</span><br></pre></td></tr></table></figure><hr /><h4 id="双重循环实现">双重循环实现</h4><p>第i个测试样本与第j个训练样本的距离<spanclass="math inline">\(dist[i,j]\)</span>等于用第i个测试图像的特征向量减去第j个训练图像的特征向量的值</p><p><spanclass="math inline">\(\sum_ndist[i,j]=\sqrt{(x_{test[i,d]}-x_{train[j,d]})^2}\)</span></p><p><imgsrc="https://github.com/serika-onoe/web-img/raw/main/CS231N/Assignment1/dij.png" /></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">compute_distances_two_loops</span>(<span class="params">self, X</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Compute the distance between each test point in X and each training point</span></span><br><span class="line"><span class="string">    in self.X_train using a nested loop over both the training data and the</span></span><br><span class="line"><span class="string">    test data.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Inputs:</span></span><br><span class="line"><span class="string">    - X: A numpy array of shape (num_test, D) containing test data.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    - dists: A numpy array of shape (num_test, num_train) where dists[i, j]</span></span><br><span class="line"><span class="string">      is the Euclidean distance between the ith test point and the jth training</span></span><br><span class="line"><span class="string">      point.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    num_test = X.shape[<span class="number">0</span>]</span><br><span class="line">    num_train = self.X_train.shape[<span class="number">0</span>]</span><br><span class="line">    dists = np.zeros((num_test, num_train))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_test):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(num_train):</span><br><span class="line">            <span class="comment">#####################################################################</span></span><br><span class="line">            <span class="comment"># <span class="doctag">TODO:</span>                                                             #</span></span><br><span class="line">            <span class="comment"># Compute the l2 distance between the ith test point and the jth    #</span></span><br><span class="line">            <span class="comment"># training point, and store the result in dists[i, j]. You should   #</span></span><br><span class="line">            <span class="comment"># not use a loop over dimension, nor use np.linalg.norm().          #</span></span><br><span class="line">            <span class="comment">#####################################################################</span></span><br><span class="line">            <span class="comment"># *****START OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)*****</span></span><br><span class="line"></span><br><span class="line">            dists[i][j]=np.sqrt(np.<span class="built_in">sum</span>(np.square(X[i,:]-self.X_train[j,:])))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># *****END OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)*****</span></span><br><span class="line">    <span class="keyword">return</span> dists</span><br></pre></td></tr></table></figure><hr /><h4 id="单循环实现">单循环实现</h4><p>利用numpy的broadcast机制，可以直接计算第i张测试图像与所有训练样本的距离</p><p><imgsrc="https://github.com/serika-onoe/web-img/raw/main/CS231N/Assignment1/dij_single.png" /></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">compute_distances_one_loop</span>(<span class="params">self, X</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Compute the distance between each test point in X and each training point</span></span><br><span class="line"><span class="string">    in self.X_train using a single loop over the test data.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Input / Output: Same as compute_distances_two_loops</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    num_test = X.shape[<span class="number">0</span>]</span><br><span class="line">    num_train = self.X_train.shape[<span class="number">0</span>]</span><br><span class="line">    dists = np.zeros((num_test, num_train))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_test):</span><br><span class="line">        <span class="comment">#######################################################################</span></span><br><span class="line">        <span class="comment"># <span class="doctag">TODO:</span>                                                               #</span></span><br><span class="line">        <span class="comment"># Compute the l2 distance between the ith test point and all training #</span></span><br><span class="line">        <span class="comment"># points, and store the result in dists[i, :].                        #</span></span><br><span class="line">        <span class="comment"># Do not use np.linalg.norm().                                        #</span></span><br><span class="line">        <span class="comment">#######################################################################</span></span><br><span class="line">        <span class="comment"># *****START OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)*****</span></span><br><span class="line"></span><br><span class="line">        dists[i,:]=np.sqrt(np.<span class="built_in">sum</span>(np.square(X[i,:]-self.X_train),axis=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># *****END OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)*****</span></span><br><span class="line">    <span class="keyword">return</span> dists</span><br></pre></td></tr></table></figure><table style="width:14%;"><colgroup><col style="width: 13%" /></colgroup><tbody><tr class="odd"><td>### 无循环实现</td></tr><tr class="even"><td>个矩阵不能直接相减，不用循环计算距离，考虑距离公式，同时需保证最后得到的dists.shape满足(num_test,num_train)</td></tr><tr class="odd"><td>(a-b)<sup>2=a</sup>2+b^2-2ab$</td></tr><tr class="even"><td><ahref="https://github.com/serika-onoe/web-img/raw/main/CS231N/Assignment1/dij_no.png"></a></td></tr><tr class="odd"><td>!--code￼5--&gt;</td></tr><tr class="even"><td>## 3. 预测：根据K个最邻近距离中的多数确定标签</td></tr><tr class="odd"><td>np.argsort() 返回一个数组排好序后各元素对应的原来的位置序号</td></tr><tr class="even"><td>xamples:</td></tr><tr class="odd"><td>!--code￼6--&gt;</td></tr><tr class="even"><td>np.bincount() 计算非负整数数组中每个值的出现次数。</td></tr><tr class="odd"><td>xamples:</td></tr><tr class="even"><td>!--code￼7--&gt;</td></tr></tbody></table><p>需要实现两个功能</p><ol type="1"><li><p>选择与测试图像最相似（距离最小）的k张训练图像np.argsort(dists[i])函数是将dist中的i行元素从小到大排列，并得到对应的index。然后再取前k个索引（也就是得到距离最近的k张图像的索引）</p></li><li><p>计算这k张图像所对应的类别出现的次数，选择出现次数最多的类别</p></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">predict_labels</span>(<span class="params">self, dists, k=<span class="number">1</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Given a matrix of distances between test points and training points,</span></span><br><span class="line"><span class="string">    predict a label for each test point.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Inputs:</span></span><br><span class="line"><span class="string">    - dists: A numpy array of shape (num_test, num_train) where dists[i, j]</span></span><br><span class="line"><span class="string">      gives the distance betwen the ith test point and the jth training point.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    - y: A numpy array of shape (num_test,) containing predicted labels for the</span></span><br><span class="line"><span class="string">      test data, where y[i] is the predicted label for the test point X[i].</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    num_test = dists.shape[<span class="number">0</span>]</span><br><span class="line">    y_pred = np.zeros(num_test)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_test):</span><br><span class="line">        <span class="comment"># A list of length k storing the labels of the k nearest neighbors to</span></span><br><span class="line">        <span class="comment"># the ith test point.</span></span><br><span class="line">        closest_y = []</span><br><span class="line">        <span class="comment">#########################################################################</span></span><br><span class="line">        <span class="comment"># <span class="doctag">TODO:</span>                                                                 #</span></span><br><span class="line">        <span class="comment"># Use the distance matrix to find the k nearest neighbors of the ith    #</span></span><br><span class="line">        <span class="comment"># testing point, and use self.y_train to find the labels of these       #</span></span><br><span class="line">        <span class="comment"># neighbors. Store these labels in closest_y.                           #</span></span><br><span class="line">        <span class="comment"># Hint: Look up the function numpy.argsort.                             #</span></span><br><span class="line">        <span class="comment">#########################################################################</span></span><br><span class="line">        <span class="comment"># *****START OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)*****</span></span><br><span class="line"></span><br><span class="line">        closest_y = self.y_train[np.argsort(dists[i])[:k]]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># *****END OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)*****</span></span><br><span class="line">        <span class="comment">#########################################################################</span></span><br><span class="line">        <span class="comment"># <span class="doctag">TODO:</span>                                                                 #</span></span><br><span class="line">        <span class="comment"># Now that you have found the labels of the k nearest neighbors, you    #</span></span><br><span class="line">        <span class="comment"># need to find the most common label in the list closest_y of labels.   #</span></span><br><span class="line">        <span class="comment"># Store this label in y_pred[i]. Break ties by choosing the smaller     #</span></span><br><span class="line">        <span class="comment"># label.                                                                #</span></span><br><span class="line">        <span class="comment">#########################################################################</span></span><br><span class="line">        <span class="comment"># *****START OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)*****</span></span><br><span class="line"></span><br><span class="line">        y_pred[i] = np.argmax(np.bincount(closest_y))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># *****END OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)*****</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> y_pred</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="knn.ipynb">knn.ipynb</h2><p>讨论knn中k的取值问题</p><ul><li>np.array_split() 将一个数组拆分为多个子数组，可以大小不等。</li></ul><p>Examples:</p><h2 id="section"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">x = np.arange(<span class="number">8.0</span>)</span><br><span class="line">np.array_split(x, <span class="number">3</span>)</span><br><span class="line">[array([<span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">2.</span>]), array([<span class="number">3.</span>,  <span class="number">4.</span>,  <span class="number">5.</span>]), array([<span class="number">6.</span>,  <span class="number">7.</span>])]</span><br><span class="line"></span><br><span class="line">x = np.arange(<span class="number">9</span>)</span><br><span class="line">np.array_split(x, <span class="number">4</span>)</span><br><span class="line">[array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]), array([<span class="number">3</span>, <span class="number">4</span>]), array([<span class="number">5</span>, <span class="number">6</span>]), array([<span class="number">7</span>, <span class="number">8</span>])]</span><br></pre></td></tr></table></figure></h2><p>knn需要选择k个近邻然后进行t投票，那么问题来了，k应该取几效果会比较好呢？</p><p>需要做两个任务：</p><ol type="1"><li>划分训练集</li><li>交叉验证</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num_folds = <span class="number">5</span></span><br><span class="line">k_choices = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="number">100</span>]</span><br><span class="line"></span><br><span class="line">X_train_folds = []</span><br><span class="line">y_train_folds = []</span><br><span class="line"><span class="comment">################################################################################</span></span><br><span class="line"><span class="comment"># <span class="doctag">TODO:</span>                                                                        #</span></span><br><span class="line"><span class="comment"># Split up the training data into folds. After splitting, X_train_folds and    #</span></span><br><span class="line"><span class="comment"># y_train_folds should each be lists of length num_folds, where                #</span></span><br><span class="line"><span class="comment"># y_train_folds[i] is the label vector for the points in X_train_folds[i].     #</span></span><br><span class="line"><span class="comment"># Hint: Look up the numpy array_split function.                                #</span></span><br><span class="line"><span class="comment">################################################################################</span></span><br><span class="line"><span class="comment"># *****START OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)*****</span></span><br><span class="line"></span><br><span class="line">X_train_folds = np.array_split(X_train,num_folds)</span><br><span class="line">y_train_folds = np.array_split(y_train,num_folds)</span><br><span class="line"></span><br><span class="line"><span class="comment"># *****END OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)*****</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A dictionary holding the accuracies for different values of k that we find</span></span><br><span class="line"><span class="comment"># when running cross-validation. After running cross-validation,</span></span><br><span class="line"><span class="comment"># k_to_accuracies[k] should be a list of length num_folds giving the different</span></span><br><span class="line"><span class="comment"># accuracy values that we found when using that value of k.</span></span><br><span class="line">k_to_accuracies = &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">################################################################################</span></span><br><span class="line"><span class="comment"># <span class="doctag">TODO:</span>                                                                        #</span></span><br><span class="line"><span class="comment"># Perform k-fold cross validation to find the best value of k. For each        #</span></span><br><span class="line"><span class="comment"># possible value of k, run the k-nearest-neighbor algorithm num_folds times,   #</span></span><br><span class="line"><span class="comment"># where in each case you use all but one of the folds as training data and the #</span></span><br><span class="line"><span class="comment"># last fold as a validation set. Store the accuracies for all fold and all     #</span></span><br><span class="line"><span class="comment"># values of k in the k_to_accuracies dictionary.                               #</span></span><br><span class="line"><span class="comment">################################################################################</span></span><br><span class="line"><span class="comment"># *****START OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)*****</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> k_choices:</span><br><span class="line">    k_to_accuracies.setdefault(k, [])</span><br><span class="line">    <span class="comment">#print(k_to_accuracies)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_folds):</span><br><span class="line">    classifier = KNearestNeighbor()</span><br><span class="line">    X_val_train = np.vstack(X_train_folds[<span class="number">0</span>:i] + X_train_folds[i+<span class="number">1</span>:])</span><br><span class="line">    y_val_train = np.hstack(y_train_folds[<span class="number">0</span>:i] + y_train_folds[i+<span class="number">1</span>:])</span><br><span class="line">    <span class="comment">#print(X_val_train, y_val_train)</span></span><br><span class="line">    classifier.train(X_val_train, y_val_train)</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> k_choices:</span><br><span class="line">        y_val_pred = classifier.predict(X_train_folds[i], k)</span><br><span class="line">        num_correct = np.<span class="built_in">sum</span>(y_val_pred == y_train_folds[i])</span><br><span class="line">        accuracy = <span class="built_in">float</span>(num_correct) / <span class="built_in">len</span>(y_val_pred)</span><br><span class="line">        k_to_accuracies[k] += [accuracy]</span><br><span class="line">        <span class="comment">#print(k,k_to_accuracies[k])</span></span><br><span class="line">    <span class="comment">#print(k_to_accuracies)</span></span><br><span class="line"><span class="comment"># *****END OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)*****</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Print out the computed accuracies</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">sorted</span>(k_to_accuracies):</span><br><span class="line">    <span class="keyword">for</span> accuracy <span class="keyword">in</span> k_to_accuracies[k]:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;k = %d, accuracy = %f&#x27;</span> % (k, accuracy))</span><br></pre></td></tr></table></figure><div class="note default no-icon flat"><p>k = 1, accuracy = 0.263000 k = 1, accuracy = 0.257000 k = 1, accuracy= 0.264000 k = 1, accuracy = 0.278000 k = 1, accuracy = 0.266000 k = 3,accuracy = 0.239000 k = 3, accuracy = 0.249000 k = 3, accuracy =0.240000 k = 3, accuracy = 0.266000 k = 3, accuracy = 0.254000 k = 5,accuracy = 0.248000 k = 5, accuracy = 0.266000 k = 5, accuracy =0.280000 k = 5, accuracy = 0.292000 k = 5, accuracy = 0.280000 k = 8,accuracy = 0.262000 k = 8, accuracy = 0.282000 k = 8, accuracy =0.273000 k = 8, accuracy = 0.290000 k = 8, accuracy = 0.273000 k = 10,accuracy = 0.265000 k = 10, accuracy = 0.296000 k = 10, accuracy =0.276000 k = 10, accuracy = 0.284000 k = 10, accuracy = 0.280000 k = 12,accuracy = 0.260000 k = 12, accuracy = 0.295000 k = 12, accuracy =0.279000 k = 12, accuracy = 0.283000 k = 12, accuracy = 0.280000 k = 15,accuracy = 0.252000 k = 15, accuracy = 0.289000 k = 15, accuracy =0.278000 k = 15, accuracy = 0.282000 k = 15, accuracy = 0.274000 k = 20,accuracy = 0.270000 k = 20, accuracy = 0.279000 k = 20, accuracy =0.279000 k = 20, accuracy = 0.282000 k = 20, accuracy = 0.285000 k = 50,accuracy = 0.271000 k = 50, accuracy = 0.288000 k = 50, accuracy =0.278000 k = 50, accuracy = 0.269000 k = 50, accuracy = 0.266000 k =100, accuracy = 0.256000 k = 100, accuracy = 0.270000 k = 100, accuracy= 0.263000 k = 100, accuracy = 0.256000 k = 100, accuracy = 0.263000</p></div><p>这里可以选出最好的k值</p><ul><li>best_k = k_choices[accuracies_mean.argmax()]</li></ul><h3 id="inline-question-1"><strong>Inline Question 1</strong></h3><p>Notice the structured patterns in the distance matrix, where somerows or columns are visibly brighter. (Note that with the default colorscheme black indicates low distances while white indicates highdistances.)</p><ul><li>What in the data is the cause behind the distinctly brightrows?</li><li>What causes the columns?</li></ul><p><span class="math inline">\(\color{blue}{\textit YourAnswer:}\)</span> <em>fill this in.</em></p><ol type="1"><li><p>The test image is far different from all the trainimage.</p></li><li><p>The train image is unsimilar to all the test image.</p></li></ol><h3 id="inline-question-2"><strong>Inline Question 2</strong></h3><p>We can also use other distance metrics such as L1 distance. For pixelvalues <span class="math inline">\(p_{ij}^{(k)}\)</span> at location<span class="math inline">\((i,j)\)</span> of some image <spanclass="math inline">\(I_k\)</span>,</p><p>the mean <span class="math inline">\(\mu\)</span> across all pixelsover all images is <spanclass="math display">\[\mu=\frac{1}{nhw}\sum_{k=1}^n\sum_{i=1}^{h}\sum_{j=1}^{w}p_{ij}^{(k)}\]</span>And the pixel-wise mean <span class="math inline">\(\mu_{ij}\)</span>across all images is <spanclass="math display">\[\mu_{ij}=\frac{1}{n}\sum_{k=1}^np_{ij}^{(k)}.\]</span>The general standard deviation <spanclass="math inline">\(\sigma\)</span> and pixel-wise standard deviation<span class="math inline">\(\sigma_{ij}\)</span> is definedsimilarly.</p><p>Which of the following preprocessing steps will not change theperformance of a Nearest Neighbor classifier that uses L1 distance?Select all that apply. 1. Subtracting the mean <spanclass="math inline">\(\mu\)</span> (<spanclass="math inline">\(\tilde{p}_{ij}^{(k)}=p_{ij}^{(k)}-\mu\)</span>.)2. Subtracting the per pixel mean <spanclass="math inline">\(\mu_{ij}\)</span> (<spanclass="math inline">\(\tilde{p}_{ij}^{(k)}=p_{ij}^{(k)}-\mu_{ij}\)</span>.)3. Subtracting the mean <span class="math inline">\(\mu\)</span> anddividing by the standard deviation <spanclass="math inline">\(\sigma\)</span>. 4. Subtracting the pixel-wisemean <span class="math inline">\(\mu_{ij}\)</span> and dividing by thepixel-wise standard deviation <spanclass="math inline">\(\sigma_{ij}\)</span>. 5. Rotating the coordinateaxes of the data.</p><p><span class="math inline">\(\color{blue}{\textit YourAnswer:}\)</span></p><p>1, 3 will not change the L1 Distance.</p><p><span class="math inline">\(\color{blue}{\textit YourExplanation:}\)</span></p><p><imgsrc="https://github.com/serika-onoe/web-img/raw/main/CS231N/Assignment1/inline1.jpg" /></p><p><imgsrc="https://github.com/serika-onoe/web-img/raw/main/CS231N/Assignment1/inline2.jpg" /></p><p><imgsrc="https://github.com/serika-onoe/web-img/raw/main/CS231N/Assignment1/inline3.jpg" /></p><h3 id="inline-question-3"><strong>Inline Question 3</strong></h3><p>Which of the following statements about <spanclass="math inline">\(k\)</span>-Nearest Neighbor (<spanclass="math inline">\(k\)</span>-NN) are true in a classificationsetting, and for all <span class="math inline">\(k\)</span>? Select allthat apply. 1. The decision boundary of the k-NN classifier is linear.2. The training error of a 1-NN will always be lower than or equal tothat of 5-NN. 3. The test error of a 1-NN will always be lower than thatof a 5-NN. 4. The time needed to classify a test example with the k-NNclassifier grows with the size of the training set. 5. None of theabove.</p><p><span class="math inline">\(\color{blue}{\textit YourAnswer:}\)</span></p><p>2, 4.</p><p><span class="math inline">\(\color{blue}{\textit YourExplanation:}\)</span></p><ol type="1"><li><p>False. It depends on the given categories of data, if you give acategory with a circle boundary to its neighborhood, it isnon-linear.</p></li><li><p>True. In fact the training error of a 1-NN is always 0, and5-NN's lower bound is 0. It is because the nearest neighbor of test datais always going to be itself in 1-NN.</p></li><li><p>False. The value of k is thus data-dependent, that is why we needto perform cross validation to determine the best k for your intendedapplication and dataset.</p></li><li><p>True. At test, KNN needs to make a full pass through the entiredata set and sort points by distance. The time needed thus grows withthe size of the data.</p></li></ol><p>参考链接:</p><ol type="1"><li>cs231n官网: https://cs231n.github.io/</li><li>cs231n作业，assignment1-knn详解（注重算法与代码的结合）:https://blog.csdn.net/qq_24906797/article/details/89245722</li><li>cs231n assignment1 knn:https://blog.csdn.net/SpicyCoder/article/details/94992552</li><li>【本课程配套的代码作业讲解见置顶评论】斯坦福CS231N计算机视觉作业讲解：https://www.bilibili.com/video/BV1t4411U78z/?spm_id_from=333.337.search-card.all.click&amp;vd_source=f0de9c6453942ba082fa767eb7aa958a</li><li>CS231N作业详解零基础版：https://www.bilibili.com/video/BV19z411b7u9/?p=6&amp;vd_source=f0de9c6453942ba082fa767eb7aa958a</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;cs231n-assignment-1&quot;&gt;CS231n Assignment 1&lt;/h1&gt;
&lt;p&gt;作业1分为五个部分：knn、SVM、Softmax classifier、2层神经网络、Higher
Level Representations: Image F</summary>
      
    
    
    
    <category term="笔记" scheme="https://serika-onoe.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="介绍" scheme="https://serika-onoe.github.io/tags/%E4%BB%8B%E7%BB%8D/"/>
    
    <category term="深度学习" scheme="https://serika-onoe.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="cs231n" scheme="https://serika-onoe.github.io/tags/cs231n/"/>
    
    <category term="作业" scheme="https://serika-onoe.github.io/tags/%E4%BD%9C%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>Transformer模型初探</title>
    <link href="https://serika-onoe.github.io/2022/12/14/Transformer%E6%A8%A1%E5%9E%8B%E5%88%9D%E6%8E%A2/"/>
    <id>https://serika-onoe.github.io/2022/12/14/Transformer%E6%A8%A1%E5%9E%8B%E5%88%9D%E6%8E%A2/</id>
    <published>2022-12-14T01:42:13.000Z</published>
    <updated>2022-12-20T14:48:56.160Z</updated>
    
    <content type="html"><![CDATA[<h1 id="transformer模型初探">Transformer模型初探</h1><h2 id="位置编码">位置编码</h2><ol type="1"><li>embedding</li><li>位置编码 面试题：RNN的梯度消失有什么不同 ## 多头注意力机制</li></ol><h2 id="残差和laternorm">残差和laterNorm</h2><h2 id="前馈神经网络">前馈神经网络</h2><h2 id="trm面试题讲解">TRM面试题讲解</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;transformer模型初探&quot;&gt;Transformer模型初探&lt;/h1&gt;
&lt;h2 id=&quot;位置编码&quot;&gt;位置编码&lt;/h2&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;embedding&lt;/li&gt;
&lt;li&gt;位置编码 面试题：RNN的梯度消失有什么不同 ## 多头注</summary>
      
    
    
    
    <category term="笔记" scheme="https://serika-onoe.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="科研" scheme="https://serika-onoe.github.io/tags/%E7%A7%91%E7%A0%94/"/>
    
    <category term="项目" scheme="https://serika-onoe.github.io/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>强化学习初探</title>
    <link href="https://serika-onoe.github.io/2022/12/12/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%88%9D%E6%8E%A2/"/>
    <id>https://serika-onoe.github.io/2022/12/12/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%88%9D%E6%8E%A2/</id>
    <published>2022-12-12T15:17:01.000Z</published>
    <updated>2022-12-13T02:17:47.012Z</updated>
    
    <content type="html"><![CDATA[<h1 id="强化学习">强化学习</h1><p>强化学习是一类对目标导向的学习与决策问题进行理解和自动化处理的算法。它强调智能体通过与环境的直接互动来学习，无需像监督学习一样密集的样本级标签标注，通过奖励来学习合理的策略。</p><p>强化学习包含2个可以进行交互的对象：智能体和环境，它们的定义与介绍如下：</p><p>智能体：可以感知环境的状态，并根据反馈的奖励学习选择一个合适的动作，我们希望它能最大化长期总收益。环境：环境会接收智能体执行的一系列动作，对这一系列动作进行评价并转换为一种可量化的信号反馈给智能体。环境对智能体来说是一套相对固定的规则。</p><h2 id="目的">目的</h2><p>强化学习的目的是让计算机自行学习，以获得最好的未来结果。它通过不断的尝试和评估来实现这一目标，从而使计算机能够根据结果自动调整自身来获得最佳结果。</p><h2 id="典型算法">典型算法</h2><p>强化学习中使用的典型算法有：Q学习、蒙特卡洛树搜索、模仿学习、深度强化学习等。</p><h2 id="优点">优点</h2><p>强化学习的优点有：</p><ul><li>可以解决复杂的决策问题，比如游戏、控制和规划。</li><li>可以快速解决不断变化的环境问题和复杂的决策问题。</li><li>可以在非常少的知识和计算量情况下学习。</li></ul><h2 id="缺点">缺点</h2><p>强化学习的缺点有：</p><ul><li>需要大量的试验数据，因此在小数据集上表现不佳。</li><li>可能会出现“收敛停滞”现象，即它可能会在局部最优解上停止收敛。</li><li>它可能会陷入错误的局部最优解。</li></ul><h2 id="应用">应用</h2><p>强化学习在实际应用中有很多，比如：自动驾驶、智能家居、游戏、虚拟助手、自动投资、博弈机器人等。</p><h2 id="参考网站">参考网站</h2><ol type="1"><li>Reinforcement Learning and ArtificialIntelligence：https://www.reinforcementlearning.ai/</li><li>Deep ReinforcementLearning：https://deepreinforcementlearning.ai/</li><li>Andrew Ng Reinforcement Learning：https://www.andrewng.org/</li><li>Open AI Gym：https://gym.openai.com/</li><li>Google DeepMind：https://deepmind.com/research/open-source/</li><li>Berkeley AI Research：https://bair.berkeley.edu/</li><li>Udacity ReinforcementLearning：https://www.udacity.com/course/reinforcement-learning--ud600</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;强化学习&quot;&gt;强化学习&lt;/h1&gt;
&lt;p&gt;强化学习是一类对目标导向的学习与决策问题进行理解和自动化处理的算法。它强调智能体通过与环境的直接互动来学习，无需像监督学习一样密集的样本级标签标注，通过奖励来学习合理的策略。&lt;/p&gt;
&lt;p&gt;强化学习包含2个可以进行交互的对</summary>
      
    
    
    
    <category term="介绍" scheme="https://serika-onoe.github.io/categories/%E4%BB%8B%E7%BB%8D/"/>
    
    
    <category term="强化学习" scheme="https://serika-onoe.github.io/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="人工智能" scheme="https://serika-onoe.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    <category term="算法" scheme="https://serika-onoe.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>我的项目经历</title>
    <link href="https://serika-onoe.github.io/2022/12/09/%E6%88%91%E7%9A%84%E7%A7%91%E7%A0%94%E7%BB%8F%E5%8E%86/"/>
    <id>https://serika-onoe.github.io/2022/12/09/%E6%88%91%E7%9A%84%E7%A7%91%E7%A0%94%E7%BB%8F%E5%8E%86/</id>
    <published>2022-12-09T03:10:23.000Z</published>
    <updated>2022-12-13T02:06:24.224Z</updated>
    
    <content type="html"><![CDATA[<h1 id="我的项目经历">我的项目经历</h1><p>目录：</p><!-- vscode-markdown-toc --><p><strong>一、软件编程项目</strong> * 1. <ahref="#">无人机集群电磁仿真设计</a> * 2. <ahref="#-1">弱监督条件下的点云语义理解</a> * 3. <ahref="#Python">Python爬取国家统计数据</a> * 4. <ahref="#app">app制作与安全性分析</a> * 5. <ahref="#-1">绕过认证系统实验</a> * 6. <a href="#AI">AI玩俄罗斯方块</a> *7. <a href="#GUI">手写数字识别GUI</a> * 8. <ahref="#DIY">马里奥DIY版</a> * 9. <a href="#-1">简易版魔塔</a> * 10. <ahref="#-1">疫情地图小程序</a></p><p><strong>二、硬件控制项目</strong> * 1. <ahref="#-1">玩具狗的多种开关方式</a> * 2. <a href="#GPS">GPS欺骗</a> * 3.<a href="#Arduino">基于Arduino的音乐播放器</a><!-- vscode-markdown-toc-config    numbering=true    autoSave=true    /vscode-markdown-toc-config --> <!-- /vscode-markdown-toc --></p><h1 id="软件编程项目">软件编程项目</h1><h2 id="无人机集群电磁仿真设计">1.<a name=''></a>无人机集群电磁仿真设计</h2><p>2021.1 - 2021.8</p><hr /><h3 id="描述">1.1. <a name='-1'></a>描述：</h3><p>我们通过以下步骤解决无人机集群的目标电磁特征数据的获取问题，提出了解决无人机集群问题目标检测的创新思路。</p><p>首先，以 "Gremlin"无人机为代表的典型单架固定翼无人机为例，基于多级快速多极法（MLFMM）进行电磁计算。然后，利用雷达散射截面（RCS）仿真数据和二维反合成孔径雷达（ISAR）成像来验证上述仿真结果的结果准确性。最后，我们对无人机集群的RCS模拟数据进行了模拟和验证。</p><p>用到的编程语言和软件工具有：</p><p>（1）Solidworks -- 建立两类无人机的三维模型 （2）Feko电磁仿真软件 --基于MLFMM对无人机进行电磁仿真计算 （3）MATLAB --仿真数据清洗和处理，ISAR成像算法实现</p><h3 id="成绩">1.2. <a name='-1'></a>成绩：</h3><p>该项目过程和结论已在2021年的CIE雷达会议上提出。</p><p><imgsrc="https://github.com/serika-onoe/web-img/raw/main/Experience/uav_prove.jpg" /></p><p>我们总结和分析了无人机目标 "Gremlin"在单一和集群情况下的电磁散射计算，这些都是基于的应用要求和技术困难。全极化静态电磁散射计算了"Gremlin"在典型频段的全极化静态电磁散射特征数据，并将其结果用于进行集群目标成像，可以清楚地看到"Gremlin "的翼尖特征。</p><h4 id="固定翼代表1--美军捕食者无人机">1.2.1.<a name='1--'></a>固定翼代表1--美军“捕食者”无人机</h4><p><imgsrc="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Finews.gtimg.com%2Fnewsapp_match%2F0%2F2985298796%2F0.jpg&amp;refer=http%3A%2F%2Finews.gtimg.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1617869104&amp;t=54d2c95a6f95de01679291e9b76837dd" /></p><center>固定翼代表1--美军“捕食者”无人机实物图</center><p><imgsrc="https://github.com/serika-onoe/web-img/raw/main/Experience/uav1.jpg" /></p><center>固定翼代表1--美军“捕食者”无人机模型图</center><h4 id="固定翼代表2--美军小精灵无人机">1.2.2.<a name='2--'></a>固定翼代表2--美军“小精灵”无人机</h4><p><imgsrc="https://github.com/serika-onoe/web-img/raw/main/Experience/uav2.jpg" /></p><center>固定翼代表2--美军“小精灵”无人机实物图</center><p><imgsrc="https://github.com/serika-onoe/web-img/raw/main/Experience/uav3.jpg" /></p><center>固定翼代表2--美军“小精灵”无人机模型图</center><h4 id="旋翼代表--大疆f450无人机">1.2.3.<a name='--F450'></a>旋翼代表--大疆F450无人机</h4><p><imgsrc="https://github.com/serika-onoe/web-img/raw/main/Experience/uav4.jpg" /></p><center>旋翼代表--大疆F450无人机实物图</center><p><imgsrc="https://github.com/serika-onoe/web-img/raw/main/Experience/uav5.jpg" /></p><center>旋翼代表--大疆F450无人机模型图</center><h2 id="弱监督条件下的点云语义理解">2.<a name='-1'></a>弱监督条件下的点云语义理解</h2><p>2020.10 - 2021.1</p><hr /><h3 id="描述-1">2.1. <a name='-1'></a>描述：</h3><p>为解决三维点云语义分割中数据标注昂贵的问题，尝试使用弱监督学习的方法进行研究。进行了论文综述，同时复现了“PointNet++”代码。</p><p><imgsrc="https://github.com/serika-onoe/web-img/raw/main/Experience/pointcloud%20mind.png" /></p><p>用到的编程语言和软件工具有：</p><p>（1）Python -- 通过Jupyter Notebook复现代码</p><h3 id="成绩-1">2.2. <a name='-1'></a>成绩：</h3><p>基于百度AI平台的PaddlePaddle框架，对十组家具图片生成的无序点云进行分类处理，复现了“PointNet++”论文中91.9%的准确率。</p><p><imgsrc="https://github.com/serika-onoe/web-img/raw/main/Experience/point%20cloud2.jpg" /></p><p><imgsrc="https://github.com/serika-onoe/web-img/raw/main/Experience/point%20cloud3.jpg" /></p><p><imgsrc="https://github.com/serika-onoe/web-img/raw/main/Experience/point%20cloud4.jpg" /></p><p><imgsrc="https://github.com/serika-onoe/web-img/raw/main/Experience/point%20cloud5.jpg" /></p><h2 id="python爬取国家统计数据">3.<a name='Python'></a>Python爬取国家统计数据</h2><p>2021.1</p><hr /><h3 id="描述-2">3.1. <a name='-1'></a>描述：</h3><p>独立完成，爬取“国家统计局”八个省份、六个季度的城乡居民收支基本情况</p><p><imgsrc="https://github.com/serika-onoe/web-img/raw/main/Experience/crawl%20mind.jpg" /></p><p><imgsrc="https://github.com/serika-onoe/web-img/raw/main/Experience/crawl2.jpg" /></p><p>用到的编程语言和软件工具有：</p><p>（1）Python -- 通过panda库实现爬虫功能，通过xlwings库实现表格处理</p><h3 id="成绩-2">3.2. <a name='-1'></a>成绩：</h3><p>爬取国家统计局八个省份、六个季度的表格数据到excel表格中，同时代码可筛去无效数据，自动整理excel表格，通过xlwings库实现数据居中、自适应列宽等功能。</p><p><imgsrc="https://github.com/serika-onoe/web-img/raw/main/Experience/crawl3.jpg" /></p><p><imgsrc="https://github.com/serika-onoe/web-img/raw/main/Experience/crawl4.jpg" /></p><h2 id="app制作与安全性分析">4.<a name='app'></a>app制作与安全性分析</h2><p>2019.10 - 2020.1</p><hr /><h3 id="描述-3">4.1. <a name='-1'></a>描述：</h3><p>app实现要求:该app具有用户/口令登录功能，并可供使用者注册。注册时口令只作长度限制（如8位长度），但强度暂不作要求。用户名/口令保存在手机上，口令保存时作加密处理（自行选择加密算法）。</p><p>功能比较简单，弹出一浮窗，显示app需要获取存储空间、设备信息、地理位置权限的提示，可选择授权或拒绝。通过在手机上运行此app，注册若干个账号，口令设置时有强口令，也有弱口令，然后分析其安全性，加以改进。</p><p><imgsrc="https://github.com/serika-onoe/web-img/raw/main/Experience/app1.png" /></p><p>客户端登录功能的相关代码（Kotlin）：</p><p><imgsrc="https://github.com/serika-onoe/web-img/raw/main/Experience/app2.png" /></p><p>获取存储空间、设备信息、地理位置权限这些权限的相关语句：</p><p><imgsrc="https://github.com/serika-onoe/web-img/raw/main/Experience/app3.png" /></p><p>Androbugs分析截图：</p><p><imgsrc="https://github.com/serika-onoe/web-img/raw/main/Experience/app5.png" /></p><p>分析后修改了原有app的注册/登录认证方式，采用OAuth2规范中的授权码模式：</p><p><imgsrc="https://github.com/serika-onoe/web-img/raw/main/Experience/app6.png" /></p><p>将外部存储改为内部存储：</p><p><imgsrc="https://github.com/serika-onoe/web-img/raw/main/Experience/app7.png" /></p><p>用到的编程语言和软件工具有：</p><p>（1）Kotlin -- 通过Android Studio实现app功能 （2）Androbugs --分析app安全性</p><h3 id="成绩-3">4.2. <a name='-1'></a>成绩：</h3><p>完整的运行视频如下：</p><p><iframe height=498 width=510 src='https://player.youku.com/embed/XNDg0MTQwNjUwOA==' frameborder=0 allowfullscreen></iframe></p><h2 id="绕过认证系统实验">5. <a name='-1'></a>绕过认证系统实验</h2><p>2019.9</p><hr /><h3 id="描述-4">5.1. <a name='-1'></a>描述：</h3><p>很多商场、饭店的商业WIFI采用了WEBPortal认证方式，但有些认证系统存在漏洞，可以利用 DNS TUNNEL绕过网关计费系统。存在这种漏洞的商业WIFI环境，并且可验证能够利用 DNSTUNNEL 穿越网关计费系统。</p><p>DNSTunnel真正用来“免密上网”，其实不太实际。尽管我们组已经“砍掉了”云服务器的开支（把代理服务器搬到本地来进行了），结果整个实验还是花掉了6块钱来购买域名。</p><p>用到的编程语言和软件工具有：</p><p>（1）树莓派 -- 搭建本地代理服务器 （2）Portal --拓扑结构分析和DNS仿真配置</p><h3 id="成绩-4">5.2. <a name='-1'></a>成绩：</h3><p>整个实验其实是告诉我们：黑客会“见缝插针”，DNS这样专门用于域名查询的协议，也可以被拿来传输数据。若将来需要做网络应用层的协议设计、维护工作，一定要加倍小心，在网络安全方面要非常谨慎。另外对于个人来说，如果连接到公共网络，一定要提高警惕，谨防“高科技偷窃”，因为我们难以知道黑客下一个目标是哪里。</p><iframe height="498" width="510" src="https://player.youku.com/embed/XNDg5NzI1OTY0OA==" frameborder="0" allowfullscreen></iframe><h2 id="ai玩俄罗斯方块">6. <a name='AI'></a>AI玩俄罗斯方块</h2><p>2018.9</p><hr /><h3 id="描述-5">6.1. <a name='-1'></a>描述：</h3><p>利用pygame实现俄罗斯方块游戏，同时设置了一个AI（甚至都可以不用机器学习算法）</p><p>用到的编程语言和软件工具有：</p><p>（1）Python -- 实现俄罗斯方块逻辑和AI算法</p><p>AI算法基本思想就是，遍历当前可操作的俄罗斯方块和下一个可操作的俄罗斯方块(根据不同的策略，即选择不同的位置和旋转角度)下落到底部后组成的所有可能的未来场景</p><p>未来场景的优劣判断依据：</p><pre><code>1）可消除的行数；2）堆积后的俄罗斯方块内的虚洞数量；3）堆积后的俄罗斯方块内的小方块数量；4）堆积后的俄罗斯方块的最高点；5）堆积后的俄罗斯方块的高度(每一列都有一个高度)标准差；6）堆积后的俄罗斯方块的高度一阶前向差分；7）堆积后的俄罗斯方块的高度一阶前向差分的标准差；8）堆积后的俄罗斯方块的最高点和最低点之差。</code></pre><p>从这些未来场景中选择一个最优的，其对应的当前可操作的俄罗斯方块的行动策略即为当前解</p><h3 id="成绩-5">6.2. <a name='-1'></a>成绩：</h3><p>视频演示一边拖动源码一边游戏在自动运行，以显示不是手动操作的hh</p><p><iframe height=498 width=510 src='https://player.youku.com/embed/XNDg0MTAwMTY4MA==' frameborder=0 allowfullscreen></iframe></p><h2 id="手写数字识别gui">7. <a name='GUI'></a>手写数字识别GUI</h2><p>2020.11 - 2021.1</p><hr /><h3 id="描述-6">7.1. <a name='-1'></a>描述：</h3><p>不使用框架，实现手写数字识别GUI开发</p><p>用到的编程语言和软件工具有：</p><p>（1）Python --开发GUI界面（基于Qt5），涉及基本bp算法实现和正则化（BN，L2正则化，RMSProp）等优化算法，并实现pyqt界面及三个功能:mnist中抽取识别,上传图片识别,画板手写识别</p><h3 id="成绩-6">7.2. <a name='-1'></a>成绩：</h3><p><iframe height=498 width=510 src='https://player.youku.com/embed/XNDg0MTAwMDg3Mg==' frameborder=0 allowfullscreen></iframe></p><h2 id="马里奥diy版">8. <a name='DIY'></a>马里奥DIY版</h2><p>2018.4 - 2018.6</p><hr /><h3 id="描述-7">8.1. <a name='-1'></a>描述：</h3><p>DIY了一个马里奥，在原版的基础上改变了生命设定和地图场景：</p><p>生命上限可以通过吃蘑菇增加，并回复一部分血量，同时若身体是小人形态则变成大人形态。受击时形态不变化，扣相应的HP。</p><p>用到的编程语言和软件工具有：</p><p>（1）Gamemaker -- 开发游戏界面，绘制游戏地图及玩法逻辑实现</p><p>成绩：</p><p><strong>通关演示及简单功能演示</strong></p><p><iframe height=498 width=510 src='https://player.youku.com/embed/XNDg0MTAwMjQxMg==' frameborder=0 allowfullscreen></iframe></p><p><strong>若HP为0，则直接死亡</strong></p><p><iframe height=498 width=510 src='https://player.youku.com/embed/XNDg0MTAwNDE1Mg==' frameborder=0 allowfullscreen></iframe></p><h2 id="简易版魔塔">9. <a name='-1'></a>简易版魔塔</h2><p>2017.11 - 2018.1</p><hr /><p>###描述：</p><p>命令行界面，可操作的简易版魔塔</p><p>用到的编程语言和软件工具有：</p><p>（1）C++ -- 通过命令行和字符串绘制游戏地图及玩法逻辑实现</p><h3 id="成绩-7">9.1. <a name='-1'></a>成绩：</h3><p><strong>通关演示及简单功能演示</strong></p><iframe height="498" width="510" src="https://player.youku.com/embed/XNDg5NzU4NDgzMg==" frameborder="0" allowfullscreen></iframe><h2 id="疫情地图小程序">10. <a name='-1'></a>疫情地图小程序</h2><p>2020.6</p><hr /><h3 id="描述-8">10.1. <a name='-1'></a>描述：</h3><p>疫情期间做的一个疫情地图，分为国内、国外两个板块，每个板块分为当日累计疫情、当日新增疫情两个子板块，引用了开课吧的数据源，颜色越深说明感染人数越多。</p><p>用到的编程语言和软件工具有：</p><p>（1）html -- 引用开课吧数据源，尝试进行数字可视化</p><h3 id="成绩-8">10.2. <a name='-1'></a>成绩：</h3><iframe height="498" width="510" src="https://player.youku.com/embed/XNDg5NzI4NDU0MA==" frameborder="0" allowfullscreen></iframe><h1 id="硬件控制项目">硬件控制项目</h1><h2 id="玩具狗的多种开关方式式">11.<a name='-1'></a>玩具狗的多种开关方式式</h2><h2 id="gps欺骗">12. <a name='GPS'></a>GPS欺骗</h2><p>2019.9 - 2019.11</p><hr /><h3 id="描述-9">12.1. <a name='-1'></a>描述：</h3><p>在Linux环境下，应用GPS卫星定位的手机,通过HackRFOne发射欺骗信号，实现点到点欺骗或轨迹欺骗，可在1、2分钟内成功欺骗到指定位置在指定轨迹内依据给定的加速度、速度进行不间断运动。</p><p>用到的编程语言和软件工具有：</p><p>（1）硬件：HackRF One -- 带 TCXO 时钟模块和天线，用于发射GPS信号 (2)软件： | 软件 | 作用 | | ---- | ---- | | Google Earth |选中欺骗地点，勾画目标轨迹 | | SatGen | 目标轨迹并存储为运动路径 | |gps-sdr-sim | 采样数据文件，生成GPS数据源 | | Gnuradio |流程图式运行GPS欺骗的程序 | | hackrf-tools |通过hackrf_transfer函数，在命令行运行GPS欺骗 |</p><p><imgsrc="https://github.com/serika-onoe/web-img/raw/main/Experience/gps%20mind.png" /></p><h3 id="成绩-9">12.2. <a name='-1'></a>成绩：</h3><p>实际手机位于广州大学城生活区某一定点静止不动，将定位欺骗至1千公里外的上海交大的操场跑道上变速跑步,全程精确度5m以内。</p><p><iframe height=498 width=510 src='https://player.youku.com/embed/XNDg0MTAwNDUyOA==' frameborder=0 allowfullscreen></iframe></p><p>2020.11 - 2021.1</p><hr /><h3 id="描述-10">12.3. <a name='-1'></a>描述：</h3><p>根据玩具电子狗，通过其电路图进行相应修改，可得到不同开关相应方式，除了下面视频外也已经实现磁控、小程序控制、蓝牙控制等方式</p><p>用到的硬件模块有：</p><ol type="1"><li>玩具电子狗 -- 具备基本行走，吠叫功能</li><li>电路板 -- 实现不同方式开关并焊接电路 （3) 蓝牙开关模块 --具有微信小程序控制系统</li></ol><h3 id="成绩-10">12.4. <a name='-1'></a>成绩：</h3><p><strong>键控开关方式</strong></p><iframe height="498" width="510" src="https://player.youku.com/embed/XNDg5NzI5MDU0MA==" frameborder="0" allowfullscreen></iframe><p><strong>温控开关方式</strong></p><iframe height="498" width="510" src="https://player.youku.com/embed/XNDg5NzI5MDcyMA==" frameborder="0" allowfullscreen></iframe><h2 id="基于arduino的音乐播放器">13.<a name='Arduino'></a>基于Arduino的音乐播放器</h2><p>2020.4 - 2020.6</p><hr /><h3 id="描述-11">13.1. <a name='-1'></a>描述：</h3><p>通过手机(串口)或电脑输入控制，实现了MP3的基本功能（曲目切换，多种播放模式，音量调节）。</p><p>用到的硬件模块有：</p><ol type="1"><li>Arduino -- 中央处理器</li><li>tf卡 -- 存储曲目 （3) 扬声器 -- 播放声音</li><li>LCD屏幕 -- 显示播放模式、曲目</li></ol><h3 id="成绩-11">13.2. <a name='-1'></a>成绩：</h3><iframe height="498" width="510" src="https://player.youku.com/embed/XNDg0MTAzMDQwOA==" frameborder="0" allowfullscreen></iframe>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;我的项目经历&quot;&gt;我的项目经历&lt;/h1&gt;
&lt;p&gt;目录：&lt;/p&gt;
&lt;!-- vscode-markdown-toc --&gt;
&lt;p&gt;&lt;strong&gt;一、软件编程项目&lt;/strong&gt; * 1. &lt;a
href=&quot;#&quot;&gt;无人机集群电磁仿真设计&lt;/a&gt; * 2. &lt;</summary>
      
    
    
    
    <category term="总结" scheme="https://serika-onoe.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="科研" scheme="https://serika-onoe.github.io/tags/%E7%A7%91%E7%A0%94/"/>
    
    <category term="项目" scheme="https://serika-onoe.github.io/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫爬取国家统计局数据</title>
    <link href="https://serika-onoe.github.io/2021/01/13/Python%E7%88%AC%E8%99%AB%E7%88%AC%E5%8F%96%E5%9B%BD%E5%AE%B6%E7%BB%9F%E8%AE%A1%E5%B1%80%E6%95%B0%E6%8D%AE/"/>
    <id>https://serika-onoe.github.io/2021/01/13/Python%E7%88%AC%E8%99%AB%E7%88%AC%E5%8F%96%E5%9B%BD%E5%AE%B6%E7%BB%9F%E8%AE%A1%E5%B1%80%E6%95%B0%E6%8D%AE/</id>
    <published>2021-01-12T16:12:47.000Z</published>
    <updated>2022-12-12T14:35:22.494Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-爬虫爬取国家统计局数据">Python爬虫爬取国家统计局数据</h1><p><strong>本次实验以爬取“<ahref="https://data.stats.gov.cn/index.htm">国家统计局</a>”首页中的【上海市城乡居民收支基本情况】为例，国家统计局其他页面的爬取方法大同小异</strong></p><h2 id="爬虫基本流程">1.爬虫基本流程</h2><ol type="1"><li>发起请求：通过http/https库向目标站点发起请求，即发送一个request，请求可以包含额外的headers等信息，等待服务器响应</li><li>获取相应内容：如果服务器能正常响应，会得到一个response，response的内容便是所要获取的页面内容，类型可能有HTML，json字符串，二进制数据（如图片视频）等类型</li><li>解析内容：得到的内容可能是HTML，可以用正则表达式，网页解析库进行解析，可能是json，可以直接转为json对象，可能是二进制数据，可以做保存或者进一步的处理<strong>（本次实验得到的解析内容是json）</strong></li><li>保存数据：可以存为文本，也可以保存至数据库，或者特定格式的文件</li></ol><h2 id="打开网页并分析">2.打开网页并分析</h2><p>国家统计局的网站很奇怪，明明是https却会告警不安全，首次打开界面如下（本人使用的是谷歌浏览器）</p><p><imgsrc="https://github.com/serika-onoe/web-img/raw/main/Python_crawler/1.jpg" /></p><p>点击“高级”-“继续前往”，方可进入首页</p><p><imgsrc="https://github.com/serika-onoe/web-img/raw/main/Python_crawler/2.jpg" /></p><p>选择“季度数据”-“分省季度数据”</p><p><imgsrc="https://github.com/serika-onoe/web-img/raw/main/Python_crawler/3.jpg" /></p><p>选择“人民生活”-“城乡收支情况”</p><p><imgsrc="https://github.com/serika-onoe/web-img/raw/main/Python_crawler/4.jpg" /></p><p>地区修改为“上海市”</p><p><imgsrc="https://github.com/serika-onoe/web-img/raw/main/Python_crawler/5.jpg" /></p><p>按下F12，进入浏览器调试模式</p><p><imgsrc="https://github.com/serika-onoe/web-img/raw/main/Python_crawler/6.jpg" /></p><p>刷新重新获取网页信息，找到easyquery.htm?m=QueryData&amp;dbc...的文件。可以先选中"XHR"过滤条件，缩小查找范围</p><p><imgsrc="https://github.com/serika-onoe/web-img/raw/main/Python_crawler/7.jpg" /></p><p>怎么确认这个文件就包含有我们要找的数据呢？点击“response”板块，向右拖动滑块可以看到表格数据可以一一对应（但数据并没有连续出现）</p><p><imgsrc="https://github.com/serika-onoe/web-img/raw/main/Python_crawler/8.jpg" /></p><p><strong>注意：这里的data和strdata看上去一样，但实际格式不一样，data是int或double格式，strdata是str格式，这个表格有一些空数据行，字符串格式方便做判断，字符串转数字使用eval()即可</strong></p><h2 id="完整代码及解析">3.完整代码及解析</h2><p><strong>注：缺少的库可以在命令行使用pip命令安装，如缺少requests库，可以在命令行输入命令</strong></p><p><code>pip install requests</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib3 </span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用urllib3.disable_warnings()在关闭SSL认证（verify=False）情况下</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将requests请求禁用安全请求警告</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests    <span class="comment"># 使用Requests发送网络请求</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time      <span class="comment"># 用来获取时间戳(计算当前时间，用于网页验证)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> json      <span class="comment"># 处理json文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  <span class="comment"># 处理数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd  <span class="comment"># np.array()转换成pd.DataFrame格式，再使用to_excel()写入excel表格</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取毫秒级时间戳，用于网页验证</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getTime</span>():</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">int</span>(<span class="built_in">round</span>(time.time() * <span class="number">1000</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据预处理，获取json列表中层层包裹的strdata元素（数据）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getList</span>(<span class="params">length</span>):</span><br><span class="line"></span><br><span class="line">  <span class="type">List</span>=[]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line"></span><br><span class="line">​    temp = js[<span class="string">&#x27;returndata&#x27;</span>][<span class="string">&#x27;datanodes&#x27;</span>][i][<span class="string">&#x27;data&#x27;</span>][<span class="string">&#x27;strdata&#x27;</span>]</span><br><span class="line"></span><br><span class="line">​    <span class="comment"># 城乡居民收支列表中，原网站有同比增长数据为空，若直接使用eval()会报错，需要先判断</span></span><br><span class="line"></span><br><span class="line">​    <span class="keyword">if</span>(<span class="built_in">len</span>(temp)!=<span class="number">0</span>):</span><br><span class="line"></span><br><span class="line">​      <span class="comment"># eval()数字转字符串</span></span><br><span class="line"></span><br><span class="line">​      <span class="type">List</span>.append(<span class="built_in">eval</span>(temp))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 请求目标网址(链接?前面的东西)</span></span><br><span class="line"></span><br><span class="line">  url=<span class="string">&#x27;https://data.stats.gov.cn/easyquery.htm&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 请求头，User-Agent: 用来证明你是浏览器，满足一定格式即可，不一定和自己的浏览器一样</span></span><br><span class="line"></span><br><span class="line">  headers=&#123;<span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0(Windows;U;Windows NT6.1;en-US;rv:1.9.1.6) Geko/20091201 Firefox/3.5.6&#x27;</span>&#125;<span class="comment">#浏览器代理</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 构造参数键值对，具体数值从网页结构参数中获取</span></span><br><span class="line"></span><br><span class="line">  key=&#123;&#125;</span><br><span class="line"></span><br><span class="line">  key[<span class="string">&#x27;m&#x27;</span>]=<span class="string">&#x27;QueryData&#x27;</span></span><br><span class="line"></span><br><span class="line">  key[<span class="string">&#x27;dbcode&#x27;</span>]=<span class="string">&#x27;fsjd&#x27;</span></span><br><span class="line"></span><br><span class="line">  key[<span class="string">&#x27;rowcode&#x27;</span>]=<span class="string">&#x27;zb&#x27;</span></span><br><span class="line"></span><br><span class="line">  key[<span class="string">&#x27;colcode&#x27;</span>]=<span class="string">&#x27;sj&#x27;</span></span><br><span class="line"></span><br><span class="line">  key[<span class="string">&#x27;wds&#x27;</span>]=<span class="string">&#x27;[&#123;&quot;wdcode&quot;:&quot;reg&quot;,&quot;valuecode&quot;:&quot;310000&quot;&#125;]&#x27;</span></span><br><span class="line"></span><br><span class="line">  key[<span class="string">&#x27;k1&#x27;</span>]=<span class="built_in">str</span>(getTime()) </span><br><span class="line"></span><br><span class="line">  <span class="comment"># &quot;wdcode&quot;:&quot;reg&quot; 地区栏</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 上海 310000 </span></span><br><span class="line"></span><br><span class="line">  key[<span class="string">&#x27;dfwds&#x27;</span>]=<span class="string">&#x27;[&#123;&quot;wdcode&quot;:&quot;zb&quot;,&quot;valuecode&quot;:&quot;A0300&quot;&#125;,&#123;&quot;wdcode&quot;:&quot;sj&quot;,&quot;valuecode&quot;:&quot;LAST6&quot;&#125;]&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># &quot;wdcode&quot;:&quot;zb&quot; 选取左侧哪个条目,&quot;wdcode&quot;:&quot;sj&quot;选项框中选取&quot;最近6季度&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 禁用安全请求警告</span></span><br><span class="line"></span><br><span class="line">  requests.packages.urllib3.disable_warnings()</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 发出请求，使用post方法，这里使用前面自定义的头部和参数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># ！！！verify=False，国家统计局20年下半年改用https协议,若不加该代码无法通过SSL验证</span></span><br><span class="line"></span><br><span class="line">  r = requests.post(url, headers=headers, params=key,verify=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 使用json库中loads函数，将r.text字符串解析成dict字典格式存储于js中</span></span><br><span class="line"></span><br><span class="line">  js = json.loads(r.text)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 得到所需数据的一维数组，利用np.array().reshape()整理为二维数组</span></span><br><span class="line"></span><br><span class="line">  length=<span class="built_in">len</span>(js[<span class="string">&#x27;returndata&#x27;</span>][<span class="string">&#x27;datanodes&#x27;</span>])</span><br><span class="line"></span><br><span class="line">  res=getList(length)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 总数据划分成6行的格式</span></span><br><span class="line"></span><br><span class="line">  array=np.array(res).reshape(<span class="built_in">len</span>(res)//<span class="number">6</span>,<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment"># np.array()转换成pd.DataFrame格式，后续可使用to_excel()直接写入excel表格</span></span><br><span class="line"></span><br><span class="line">  df_shanghai=pd.DataFrame(array)</span><br><span class="line"></span><br><span class="line">  df_shanghai.columns=[<span class="string">&#x27;2020年第三季度&#x27;</span>,<span class="string">&#x27;2020年第二季度&#x27;</span>,<span class="string">&#x27;2020年第一季度&#x27;</span>,<span class="string">&#x27;2019年第四季度&#x27;</span>,</span><br><span class="line"></span><br><span class="line">​        <span class="string">&#x27;2019年第三季度&#x27;</span>,<span class="string">&#x27;2019年第二季度&#x27;</span>]</span><br><span class="line"></span><br><span class="line">  df_shanghai.index=[<span class="string">&#x27;居民人均可支配收入累计值(元)&#x27;</span>,</span><br><span class="line"></span><br><span class="line">​       <span class="string">&#x27;城镇居民人均可支配收入累计值(元)&#x27;</span>,</span><br><span class="line"></span><br><span class="line">​       <span class="string">&#x27;农村居民人均可支配收入累计值(元)&#x27;</span>,</span><br><span class="line"></span><br><span class="line">​       <span class="string">&#x27;居民人均消费支出累计值(元)&#x27;</span>,</span><br><span class="line"></span><br><span class="line">​        <span class="string">&#x27;城镇居民人均消费支出累计值(元)&#x27;</span>,</span><br><span class="line"></span><br><span class="line">​       <span class="string">&#x27;农村居民人均消费支出累计值(元)&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(df_shanghai)</span><br></pre></td></tr></table></figure><p><imgsrc="https://github.com/serika-onoe/web-img/raw/main/Python_crawler/9.jpg" /></p><h2 id="部分代码说明">4.部分代码说明</h2><h3 id="数据提取">数据提取</h3><p>得到表格中的数据需要先分析提取到的js文件，打印内容如下：</p><p><imgsrc="https://github.com/serika-onoe/web-img/raw/main/Python_crawler/10.jpg" /></p><p>将五层列表层层剥开，得到需要的strdata</p><p><imgsrc="https://github.com/serika-onoe/web-img/raw/main/Python_crawler/11.jpg" /></p><h3 id="请求网站">请求网站</h3><p>请求目标网址(''?''前面的东西)</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">url=<span class="string">&#x27;https://data.stats.gov.cn/easyquery.htm&#x27;</span></span><br></pre></td></tr></table></figure><p><imgsrc="https://github.com/serika-onoe/web-img/raw/main/Python_crawler/12.jpg" /></p><p>请求头，User-Agent:用来证明你是浏览器，满足一定格式即可，不一定要和自己的浏览器一样</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">headers=&#123;<span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0(Windows;U;Windows NT6.1;en-US;rv:1.9.1.6) Geko/20091201 Firefox/3.5.6&#x27;</span>&#125;<span class="comment">#浏览器代理</span></span><br></pre></td></tr></table></figure><p><imgsrc="https://github.com/serika-onoe/web-img/raw/main/Python_crawler/13.jpg" /></p><p>构造参数键值对，下列参数会以 &amp; 连接，放在链接的''?''后面</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">key=&#123;&#125;</span><br><span class="line">key[<span class="string">&#x27;m&#x27;</span>]=<span class="string">&#x27;QueryData&#x27;</span></span><br><span class="line">key[<span class="string">&#x27;dbcode&#x27;</span>]=<span class="string">&#x27;fsjd&#x27;</span></span><br><span class="line">key[<span class="string">&#x27;rowcode&#x27;</span>]=<span class="string">&#x27;zb&#x27;</span></span><br><span class="line">key[<span class="string">&#x27;colcode&#x27;</span>]=<span class="string">&#x27;sj&#x27;</span></span><br><span class="line">key[<span class="string">&#x27;wds&#x27;</span>]=<span class="string">&#x27;[&#123;&quot;wdcode&quot;:&quot;reg&quot;,&quot;valuecode&quot;:&quot;310000&quot;&#125;]&#x27;</span></span><br><span class="line">key[<span class="string">&#x27;k1&#x27;</span>]=<span class="built_in">str</span>(getTime())  </span><br><span class="line">key[<span class="string">&#x27;dfwds&#x27;</span>]=<span class="string">&#x27;[&#123;&quot;wdcode&quot;:&quot;zb&quot;,&quot;valuecode&quot;:&quot;A0300&quot;&#125;,&#123;&quot;wdcode&quot;:&quot;sj&quot;,&quot;valuecode&quot;:&quot;LAST6&quot;&#125;]&#x27;</span></span><br></pre></td></tr></table></figure><p><imgsrc="https://github.com/serika-onoe/web-img/raw/main/Python_crawler/14.jpg" /></p><p>部分参数可以从下图所示位置查看到，有些不显示的为默认，如果需要显示相同页面，需选取选项框中的相应选项</p><p><imgsrc="https://github.com/serika-onoe/web-img/raw/main/Python_crawler/15.jpg" /></p><h2 id="数据保存到excel表格">5.数据保存到excel表格</h2><p>爬虫爬到的数据现以panda.dataframe格式存储，可以利用to_excel()函数，直接保存在excel表格中</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># write对象为该Excel工作簿，使用该方法保存多个工作表</span></span><br><span class="line">    write = pd.ExcelWriter(<span class="string">&#x27;F:/Ivory_Tower/norm/分省季度数据_城乡居民收支.xls&#x27;</span>) <span class="comment">#该路径自己设置即可，没有该文件的话会自行创建一个，存在的话写入会覆盖原内容</span></span><br><span class="line">    df_shanghai.to_excel(write,sheet_name=<span class="string">&#x27;上海&#x27;</span>)</span><br><span class="line">    <span class="comment">#如果爬多个省份的数据，可以写入多个工作表，且必须要加上save()保存</span></span><br><span class="line">    write.save()</span><br></pre></td></tr></table></figure><p><imgsrc="https://github.com/serika-onoe/web-img/raw/main/Python_crawler/16.jpg" /></p><h2 id="表格优化可选">6.表格优化（可选）</h2><p>可以借助python代码，优化表格格式，如上图所示的结果不尽人意，至少还需要自动调整列宽。</p><p>这里本人采用xlwings库，需要先在命令行下载相应的库</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install xlwings</span><br><span class="line">pip install pywin32</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用xlwings库，利用python编辑整理Excel表格</span></span><br><span class="line"><span class="keyword">import</span> xlwings <span class="keyword">as</span> xw</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app=xw.App(visible=<span class="literal">False</span>,add_book=<span class="literal">False</span>) <span class="comment">#过程不可见，不添加新工作表</span></span><br><span class="line">    wb=app.books.<span class="built_in">open</span>(<span class="string">r&#x27;F:/Ivory_Tower/norm/分省季度数据_城乡居民收支.xls&#x27;</span>)</span><br><span class="line">    <span class="comment"># wb就是新建的工作簿(workbook)</span></span><br><span class="line">    <span class="comment"># 对8个工作表，分别进行操作</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>): </span><br><span class="line">        rng=wb.sheets[i].<span class="built_in">range</span>(<span class="string">&#x27;A1:H20&#x27;</span>)      <span class="comment"># 选中这些单元格</span></span><br><span class="line">        rng.api.HorizontalAlignment = -<span class="number">4108</span>   <span class="comment"># 文字水平方向居中</span></span><br><span class="line">        rng.autofit()                         <span class="comment"># 自动调整行高列宽</span></span><br><span class="line">    wb.save()</span><br><span class="line">    wb.close()</span><br><span class="line">    app.quit()</span><br></pre></td></tr></table></figure><p>运行代码，即可得到以下效果（后续多爬了其他一些省份，在key处修改相应参数即可）</p><p><imgsrc="https://github.com/serika-onoe/web-img/raw/main/Python_crawler/17.jpg" /></p><h2 id="参考资料">7.参考资料</h2><p>史上超详细python爬取国家统计局数据：https://blog.csdn.net/qq_41988893/article/details/103017854</p><p>如果报其他各种各样莫名其妙的错，可以评论或私信询问哦~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;python-爬虫爬取国家统计局数据&quot;&gt;Python
爬虫爬取国家统计局数据&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;本次实验以爬取“&lt;a
href=&quot;https://data.stats.gov.cn/index.htm&quot;&gt;国家统计局&lt;/a&gt;”首页中的【上海市城乡</summary>
      
    
    
    
    <category term="项目详情" scheme="https://serika-onoe.github.io/categories/%E9%A1%B9%E7%9B%AE%E8%AF%A6%E6%83%85/"/>
    
    
    <category term="Python" scheme="https://serika-onoe.github.io/tags/Python/"/>
    
    <category term="爬虫" scheme="https://serika-onoe.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>游戏内抽卡机制总结</title>
    <link href="https://serika-onoe.github.io/2020/09/06/%E6%B8%B8%E6%88%8F%E5%86%85%E6%8A%BD%E5%8D%A1%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93/"/>
    <id>https://serika-onoe.github.io/2020/09/06/%E6%B8%B8%E6%88%8F%E5%86%85%E6%8A%BD%E5%8D%A1%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93/</id>
    <published>2020-09-06T03:00:00.000Z</published>
    <updated>2022-12-11T03:55:10.746Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面">写在前面</h2><p>卡牌类游戏很好地搭载了二次元的核心元素——“角色”，抽卡活动对库存货币消耗和新增货币均有很大的正面作用，且参与了抽卡活动的玩家也占了充值用户相当高的比例。抽卡活动确实是当前非常重要的付费点</p><p>但本人深知“玄不改非，氪能改命”，而因为是轻度玩家并不想充钱变强，所以卡牌游戏玩的并不多，阴阳师、明日方舟、剑与远征等都略有接触，而每个游戏都有着属于自己的抽卡概率。</p><p>像阴阳师的SSR大体在1%左右，而剑与远征的概率在4.8%左右，但为了用户体验，最重要的是不能让时间玩家拉开RMB玩家的差距，不能违反大R碾压小R的原则，所以所谓随机基本都是伪随机。</p><p>纯干货，为了不影响阅读就不放图片了，下面介绍一些常见的抽卡机制。</p><h3 id="保底机制">①保底机制</h3><p>这是最简单，也最普遍的一种机制，如《王者荣耀》，购买次数到达361次时，荣耀水晶产出概率为100%。《剑与远征》两个保底机制，30抽必出紫卡，在同卡池内累计抽30次即可获得出一张紫卡英雄不论是单抽还是连抽，只要数量达到即必出紫卡。</p><p>还有一个保底机制就是10连抽必出一个稀有或者精英级别的英雄，和30抽不一样的地方在于只能是适用于十连抽而不能适用于十次单抽。</p><p>保底机制保证了玩家的最终体验</p><h3 id="玄学抽奖法">②玄学抽奖法</h3><p>在一些抽卡游戏里是用一定作用的，可能由于游戏开发者在写抽卡的程序时，有时候会引用其他数据，然后增加一定算法，来决定抽到哪一张卡，这就是玩家玄学的由来。</p><p>如果引用的数据是当前系统时间，那么有可能出现“凌晨某个时间点抽卡中奖率高，或者每小时的前十分钟中奖率高”</p><p>虽说结果都在你抽卡的那一刻，在服务器就决定好，这就与抽卡画出什么图案、使用哪种方法无关，但游戏厂商还是乐意留下一个玩家主导的过程，让玩家相信是抽卡过程影响抽卡结果，对抽卡这一过程充满仪式感。</p><h3id="概率递增不知道业内是不是叫水位">③概率递增（不知道业内是不是叫水位）</h3><p>概率递增法，是指抽卡时，抽卡次数越多，爆率越高的抽卡方法。如果在还没累积到这个数值前已经抽到，那么就将概率归零。</p><p>可以让玩家的游戏体验保持在一个比较均衡的位置。</p><h3 id="奖池划分">④奖池划分</h3><p>这种抽卡方法比较复杂，在一些频繁出新卡的游戏里比较多。</p><p>当玩家抽取时候，会先判定玩家进入哪个奖池（R,SR,SSR），然后再判定玩家在这个奖池里抽到哪一张卡。如果官方加入一张新卡，会单出一个奖池，暗中去掉一张旧卡，玩家不会太过关注旧卡的出卡率，也乐意多抽出新卡。</p><h3 id="剧本抽卡">⑤剧本抽卡</h3><p>《空当接龙》所有的牌组都已经写好，每次开始游戏，就从牌组剧本中挑选一个。</p><p>《斗地主》游戏官方会特意编写出多连对，多飞机，多炸弹的牌组，随机发牌很可能出现散牌。</p><h3 id="氪金区分抽卡">⑥氪金区分抽卡</h3><p>原来的游戏是充值多少送一次抽奖，且一般都能得到非常珍贵的游戏道具。现在会暗中增加一个数据栏，计算玩家充值的数量，划分等级调整概率，来提高氪金玩家的游戏体验。</p><p>如果某种货币既可以从游戏内肝到，也可以选择充值得到，那么官方可以暗中设定一个状态栏，将活动肝到的和充值得到的区别开，每次抽奖，都会识别这次抽奖所使用的钻石是哪种类型的钻石。如果使用的过程中两种同时使用，可能默认都是充值得到的，这时概率会比用肝到的大。</p><h3 id="与抽卡促销的其他玩法">⑦与抽卡促销的其他玩法</h3><p>常见的表现方式是进入游戏，就给玩家一笔足够首抽的钱，引导玩家进行抽奖然后获得珍贵道具。</p><p>或者抽奖时，系统突然提醒你：你获得了一个购买稀有道具的机会，并附带增加时间限制。</p><p>还有一种方法是根据新玩家的道具需求，调整不同物品的爆率。比如收集套装正缺那一个部件，很可能抽奖的时候就爆出来。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;卡牌类游戏很好地搭载了二次元的核心元素——“角色”，抽卡活动对库存货币消耗和新增货币均有很大的正面作用，且参与了抽卡活动的玩家也占了充值用户相当高的比例。抽卡活动确实是当前非常重要的付费点&lt;/p&gt;
&lt;p&gt;但本人深知“玄不改</summary>
      
    
    
    
    <category term="游戏" scheme="https://serika-onoe.github.io/categories/%E6%B8%B8%E6%88%8F/"/>
    
    
    <category term="二次元" scheme="https://serika-onoe.github.io/tags/%E4%BA%8C%E6%AC%A1%E5%85%83/"/>
    
    <category term="抽卡" scheme="https://serika-onoe.github.io/tags/%E6%8A%BD%E5%8D%A1/"/>
    
    <category term="游戏" scheme="https://serika-onoe.github.io/tags/%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>我的第一篇博客</title>
    <link href="https://serika-onoe.github.io/2020/02/11/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <id>https://serika-onoe.github.io/2020/02/11/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</id>
    <published>2020-02-11T04:14:00.000Z</published>
    <updated>2022-12-12T14:40:38.284Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么要写博客">为什么要写博客</h1><p>记录博客是酝酿很久的想法，相信多数人作出这一决定也都经历了较长时间的拖延症hh。不过除了习惯性偷懒，也有出于对自身技术水平不自信的考量，毕竟大牛是极少数，多数人不过是在平均线上徘徊。</p><p>不过大脑做决定并不是纯粹理性的，反而主要凭感性。立下了靶子，定下来方向，理性思维才会积极地把行为合理化。</p><p>对为什么突发奇想开始记录博客，个人总结了如下动机：</p><ul><li><p>无论课内外，本人都已养成了动笔前先查阅大量资料的习惯。心里对那些具有开源精神的大牛们、前辈们充满敬意和感激。很多时候，一个简洁清晰的结论、一行高度概括的代码，单靠自己的探索往往要事倍功半，甚至还可能因为其在知识盲区(UnknownUnknown)而作不必要的苦恼，被前辈们留下的博客文章中不经意地一语道破，这样的瞬间简直不要太多。</p></li><li><p>从一个纯小白进化到现在一个在很多领域都有些入门经验的....小白来说，也很希望把当时掉进去的坑补上，最起码在前面做个警示，新人在环境搭建阶段没必要走弯路，把重心放在解决需求的程序调试阶段，实现更高的自我提升效率。</p></li><li><p>俗话说得好：“好记性不如烂笔头。”之前看过一本讲如何高效记笔记的书，但纸面的笔记也常常无法翻阅。加上现在经常用手机浏览很多碎片化的知识点，得不到有效的整理，博客的存在比起私人笔记，也有种民主监督的意味在里头，避免个人认知偏差和局限。</p></li><li><p>还有《暗时间》，让我受益匪浅，学习的时候我也会经常想象如何把知识向一个小白讲解，而博客也相当于把这个过程实例化，可视化。</p></li></ul><h1 id="博客记录什么">博客记录什么</h1><p>大学期间，课内学的很多是原理层面的东西，课外兴趣广泛，为避免犯蜻蜓点水般浅尝辄止的毛病，我总结所学以下几个方面的知识技术，抽空进行记录：</p><ul><li>编程语言类：C、Python、JAVA等</li><li>软件安装类: Android Studio，WordPress等</li><li>音频编辑类：pr，ps，au等等</li></ul><p>博客更新频率尽量保持在一周一两次，在此先作个纪念，日后若需要再加更改。</p><p>有诗云:“青山一道同云雨，明月何曾是两乡。”</p><p>愿与诸君共勉。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;为什么要写博客&quot;&gt;为什么要写博客&lt;/h1&gt;
&lt;p&gt;记录博客是酝酿很久的想法，相信多数人作出这一决定也都经历了较长时间的拖延症hh。不过除了习惯性偷懒，也有出于对自身技术水平不自信的考量，毕竟大牛是极少数，多数人不过是在平均线上徘徊。&lt;/p&gt;
&lt;p&gt;不过大脑做决</summary>
      
    
    
    
    <category term="总结" scheme="https://serika-onoe.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="介绍" scheme="https://serika-onoe.github.io/tags/%E4%BB%8B%E7%BB%8D/"/>
    
  </entry>
  
</feed>
